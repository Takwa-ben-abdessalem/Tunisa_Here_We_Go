import { Component, EventEmitter, forwardRef, Input, Output, ViewChild } from '@angular/core';
import { FormControl, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { MatValidateAddressDirective } from '../directives/address-validator/mat-address-validator.directive';
import * as i0 from "@angular/core";
import * as i1 from "@agm/core";
import * as i2 from "@angular/material/form-field";
import * as i3 from "@angular/material/input";
import * as i4 from "@angular/forms";
import * as i5 from "../directives/address-validator/mat-address-validator.directive";
import * as i6 from "@angular/common";
export var Appearance;
(function (Appearance) {
    Appearance["STANDARD"] = "standard";
    Appearance["FILL"] = "fill";
    Appearance["OUTLINE"] = "outline";
    Appearance["LEGACY"] = "legacy";
})(Appearance || (Appearance = {}));
export class MatGoogleMapsAutocompleteComponent {
    constructor(mapsAPILoader, ngZone) {
        this.mapsAPILoader = mapsAPILoader;
        this.ngZone = ngZone;
        this.addressLabelText = 'Address';
        this.placeholderText = 'Please enter the address';
        this.requiredErrorText = 'The address is required';
        this.invalidErrorText = 'The address is not valid';
        this.appearance = Appearance.STANDARD;
        this.autoCompleteOptions = {};
        this.onChange = new EventEmitter();
        this.onAutocompleteSelected = new EventEmitter();
        this.onGermanAddressMapped = new EventEmitter();
        this.onLocationSelected = new EventEmitter();
        this.onNewPlaceResult = new EventEmitter();
        this.addressValidator = new MatValidateAddressDirective();
        this.addressSearchControl = new FormControl({ value: null }, Validators.compose([
            Validators.required,
            this.addressValidator.validate()
        ]));
        this.propagateChange = (_) => {
        };
    }
    ngOnInit() {
        this.addressValidator.subscribe(this.onNewPlaceResult);
        const options = {
            // types: ['address'],
            // componentRestrictions: {country: this.country},
            placeIdOnly: this.placeIdOnly,
            strictBounds: this.strictBounds,
            // types: this.types,
            type: this.type
        };
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.componentRestrictions = { country: this.country } : null;
        // tslint:disable-next-line:no-unused-expression
        this.country ? options.types = this.types : null;
        this.autoCompleteOptions = Object.assign(this.autoCompleteOptions, options);
        this.initGoogleMapsAutocomplete();
    }
    initGoogleMapsAutocomplete() {
        this.mapsAPILoader
            .load()
            .then(() => {
            const autocomplete = new google.maps.places.Autocomplete(this.searchElementRef.nativeElement, this.autoCompleteOptions);
            autocomplete.addListener('place_changed', () => {
                this.ngZone.run(() => {
                    // get the place result
                    const place = autocomplete.getPlace();
                    const germanAddress = {
                        gmID: place.id,
                        icon: place.icon,
                        url: place.url,
                        placeID: place.place_id,
                        displayAddress: place.formatted_address,
                        name: place.name,
                        vicinity: place.vicinity,
                        locality: {},
                        state: {},
                        country: {},
                        geoLocation: { latitude: -1, longitude: -1 },
                    };
                    if (place.geometry && place.geometry.location) {
                        germanAddress.geoLocation.latitude = place.geometry.location.lat();
                        germanAddress.geoLocation.longitude = place.geometry.location.lng();
                    }
                    place.address_components.forEach(value => {
                        if (value.types.indexOf('street_number') > -1) {
                            germanAddress.streetNumber = value.short_name;
                        }
                        if (value.types.indexOf('route') > -1) {
                            germanAddress.streetName = value.long_name;
                        }
                        if (value.types.indexOf('postal_code') > -1) {
                            germanAddress.postalCode = Number(value.short_name);
                        }
                        if (value.types.indexOf('sublocality') > -1) {
                            germanAddress.sublocality = value.long_name;
                        }
                        if (value.types.indexOf('locality') > -1) {
                            germanAddress.locality.long = value.long_name;
                            germanAddress.locality.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_1') > -1) {
                            germanAddress.state.long = value.long_name;
                            germanAddress.state.short = value.short_name;
                        }
                        if (value.types.indexOf('country') > -1) {
                            germanAddress.country.long = value.long_name;
                            germanAddress.country.short = value.short_name;
                        }
                        if (value.types.indexOf('administrative_area_level_3') > -1) {
                            germanAddress.locality.short = value.short_name;
                        }
                    });
                    this.onGermanAddressMapped.emit(germanAddress);
                    if (!place.place_id || place.geometry === undefined || place.geometry === null) {
                        // place result is not valid
                        return;
                    }
                    else {
                        // show dialog to select a address from the input
                        // emit failed event
                        this.value = place;
                        this.propagateChange(this.value);
                    }
                    this.address = place.formatted_address;
                    this.onAutocompleteSelected.emit(place);
                    // console.log('onAutocompleteSelected -> ', place);
                    this.onLocationSelected.emit({
                        latitude: place.geometry.location.lat(),
                        longitude: place.geometry.location.lng()
                    });
                });
            });
        })
            .catch((err) => console.log(err));
    }
    onQuery(event) {
        // console.log('onChange()', event);
        this.onChange.emit(this.address);
    }
    resetAddress() {
        this.address = null;
        this.addressSearchControl.updateValueAndValidity();
    }
    writeValue(obj) {
        if (obj) {
            this.value = obj;
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        throw new Error('Method not implemented.');
    }
    setDisabledState(isDisabled) {
        throw new Error('Method not implemented.');
    }
}
MatGoogleMapsAutocompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, deps: [{ token: i1.MapsAPILoader }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
MatGoogleMapsAutocompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.2", type: MatGoogleMapsAutocompleteComponent, selector: "mat-google-maps-autocomplete", inputs: { addressLabelText: "addressLabelText", placeholderText: "placeholderText", requiredErrorText: "requiredErrorText", invalidErrorText: "invalidErrorText", appearance: "appearance", value: "value", address: "address", country: "country", placeIdOnly: "placeIdOnly", strictBounds: "strictBounds", types: "types", type: "type", autoCompleteOptions: "autoCompleteOptions" }, outputs: { onChange: "onChange", onAutocompleteSelected: "onAutocompleteSelected", onGermanAddressMapped: "onGermanAddressMapped", onLocationSelected: "onLocationSelected" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),
            multi: true
        }
    ], viewQueries: [{ propertyName: "searchElementRef", first: true, predicate: ["search"], descendants: true }], exportAs: ["matGoogleMapsAutocomplete"], ngImport: i0, template: "<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n", styles: [".full-width{width:100%}\n"], components: [{ type: i2.MatFormField, selector: "mat-form-field", inputs: ["color", "appearance", "hideRequiredMarker", "hintLabel", "floatLabel"], exportAs: ["matFormField"] }], directives: [{ type: i2.MatLabel, selector: "mat-label" }, { type: i3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i5.MatValidateAddressDirective, selector: "[mat-address-validate][formControlName],[MatValidateAddress][formControl],[MatValidateAddress][ngModel]" }, { type: i4.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i4.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.MatError, selector: "mat-error", inputs: ["id"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: MatGoogleMapsAutocompleteComponent, decorators: [{
            type: Component,
            args: [{ selector: 'mat-google-maps-autocomplete', exportAs: 'matGoogleMapsAutocomplete', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => MatGoogleMapsAutocompleteComponent),
                            multi: true
                        }
                    ], template: "<mat-form-field class=\"full-width\" [appearance]=\"appearance\">\n  <mat-label>{{addressLabelText}}</mat-label>\n  <input matInput\n         [(ngModel)]=\"address\"\n         (change)=\"onQuery($event)\"\n         placeholder=\"{{placeholderText}}\"\n         class=\"form-control\"\n         #search\n         MatValidateAddress\n         required>\n  <mat-error *ngIf=\"addressSearchControl.hasError('required')\">\n    {{requiredErrorText}}\n  </mat-error>\n  <mat-error *ngIf=\"addressSearchControl.hasError('validateAddress')\">\n    {{invalidErrorText}}\n  </mat-error>\n</mat-form-field>\n", styles: [".full-width{width:100%}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.MapsAPILoader }, { type: i0.NgZone }]; }, propDecorators: { searchElementRef: [{
                type: ViewChild,
                args: ['search']
            }], addressLabelText: [{
                type: Input
            }], placeholderText: [{
                type: Input
            }], requiredErrorText: [{
                type: Input
            }], invalidErrorText: [{
                type: Input
            }], appearance: [{
                type: Input
            }], value: [{
                type: Input
            }], address: [{
                type: Input
            }], country: [{
                type: Input
            }], placeIdOnly: [{
                type: Input
            }], strictBounds: [{
                type: Input
            }], types: [{
                type: Input
            }], type: [{
                type: Input
            }], autoCompleteOptions: [{
                type: Input
            }], onChange: [{
                type: Output
            }], onAutocompleteSelected: [{
                type: Output
            }], onGermanAddressMapped: [{
                type: Output
            }], onLocationSelected: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLW1hdGVyaWFsLWV4dGVuc2lvbnMvZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlL3NyYy9saWIvY29tcG9uZW50L21hdC1nb29nbGUtbWFwcy1hdXRvY29tcGxldGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1tYXRlcmlhbC1leHRlbnNpb25zL2dvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS9zcmMvbGliL2NvbXBvbmVudC9tYXQtZ29vZ2xlLW1hcHMtYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQWMsWUFBWSxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQWtCLE1BQU0sRUFBRSxTQUFTLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDeEgsT0FBTyxFQUF1QixXQUFXLEVBQUUsaUJBQWlCLEVBQUUsVUFBVSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFaEcsT0FBTyxFQUFDLDJCQUEyQixFQUFDLE1BQU0saUVBQWlFLENBQUM7Ozs7Ozs7O0FBTTVHLE1BQU0sQ0FBTixJQUFZLFVBS1g7QUFMRCxXQUFZLFVBQVU7SUFDcEIsbUNBQXFCLENBQUE7SUFDckIsMkJBQWEsQ0FBQTtJQUNiLGlDQUFtQixDQUFBO0lBQ25CLCtCQUFpQixDQUFBO0FBQ25CLENBQUMsRUFMVyxVQUFVLEtBQVYsVUFBVSxRQUtyQjtBQWVELE1BQU0sT0FBTyxrQ0FBa0M7SUFxRTdDLFlBQW9CLGFBQTRCLEVBQzVCLE1BQWM7UUFEZCxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUM1QixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBaEVsQyxxQkFBZ0IsR0FBRyxTQUFTLENBQUM7UUFHN0Isb0JB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QUFLO2dCQUlOLG1CQUFtQjtzQkFEbEIsS0FBSztnQkFJTixRQUFRO3NCQURQLE1BQU07Z0JBSVAsc0JBQXNCO3NCQURyQixNQUFNO2dCQUlQLHFCQUFxQjtzQkFEcEIsTUFBTTtnQkFJUCxrQkFBa0I7c0JBRGpCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCwgTmdab25lLCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29udHJvbFZhbHVlQWNjZXNzb3IsIEZvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUiwgVmFsaWRhdG9yc30gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtNYXBzQVBJTG9hZGVyfSBmcm9tICdAYWdtL2NvcmUnO1xuaW1wb3J0IHtNYXRWYWxpZGF0ZUFkZHJlc3NEaXJlY3RpdmV9IGZyb20gJy4uL2RpcmVjdGl2ZXMvYWRkcmVzcy12YWxpZGF0b3IvbWF0LWFkZHJlc3MtdmFsaWRhdG9yLmRpcmVjdGl2ZSc7XG5pbXBvcnQge0xvY2F0aW9ufSBmcm9tICcuLi9pbnRlcmZhY2VzL2xvY2F0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQge0dlcm1hbkFkZHJlc3N9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xuaW1wb3J0IFBsYWNlUmVzdWx0ID0gZ29vZ2xlLm1hcHMucGxhY2VzLlBsYWNlUmVzdWx0O1xuaW1wb3J0IEF1dG9jb21wbGV0ZU9wdGlvbnMgPSBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlT3B0aW9ucztcblxuZXhwb3J0IGVudW0gQXBwZWFyYW5jZSB7XG4gIFNUQU5EQVJEID0gJ3N0YW5kYXJkJyxcbiAgRklMTCA9ICdmaWxsJyxcbiAgT1VUTElORSA9ICdvdXRsaW5lJyxcbiAgTEVHQUNZID0gJ2xlZ2FjeScsXG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21hdC1nb29nbGUtbWFwcy1hdXRvY29tcGxldGUnLFxuICBleHBvcnRBczogJ21hdEdvb2dsZU1hcHNBdXRvY29tcGxldGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vbWF0LWdvb2dsZS1tYXBzLWF1dG9jb21wbGV0ZS5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL21hdC1nb29nbGUtbWFwcy1hdXRvY29tcGxldGUuY29tcG9uZW50LnNjc3MnXSxcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNYXRHb29nbGVNYXBzQXV0b2NvbXBsZXRlQ29tcG9uZW50KSxcbiAgICAgIG11bHRpOiB0cnVlXG4gICAgfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIE1hdEdvb2dsZU1hcHNBdXRvY29tcGxldGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICBAVmlld0NoaWxkKCdzZWFyY2gnKVxuICBwdWJsaWMgc2VhcmNoRWxlbWVudFJlZjogRWxlbWVudFJlZjtcblxuICBASW5wdXQoKVxuICBhZGRyZXNzTGFiZWxUZXh0ID0gJ0FkZHJlc3MnO1xuXG4gIEBJbnB1dCgpXG4gIHBsYWNlaG9sZGVyVGV4dCA9ICdQbGVhc2UgZW50ZXIgdGhlIGFkZHJlc3MnO1xuXG4gIEBJbnB1dCgpXG4gIHJlcXVpcmVkRXJyb3JUZXh0ID0gJ1RoZSBhZGRyZXNzIGlzIHJlcXVpcmVkJztcblxuICBASW5wdXQoKVxuICBpbnZhbGlkRXJyb3JUZXh0ID0gJ1RoZSBhZGRyZXNzIGlzIG5vdCB2YWxpZCc7XG5cbiAgQElucHV0KClcbiAgYXBwZWFyYW5jZTogc3RyaW5nIHwgQXBwZWFyYW5jZSA9IEFwcGVhcmFuY2UuU1RBTkRBUkQ7XG5cbiAgQElucHV0KClcbiAgdmFsdWU6IFBsYWNlUmVzdWx0O1xuXG4gIEBJbnB1dCgpXG4gIGFkZHJlc3M6IFBsYWNlUmVzdWx0IHwgc3RyaW5nO1xuXG4gIEBJbnB1dCgpXG4gIGNvdW50cnk6IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIEBJbnB1dCgpXG4gIHBsYWNlSWRPbmx5PzogYm9vbGVhbjtcblxuICBASW5wdXQoKVxuICBzdHJpY3RCb3VuZHM/OiBib29sZWFuO1xuXG4gIEBJbnB1dCgpXG4gIHR5cGVzPzogc3RyaW5nW107XG4gIC8vIHR5cGVzOiBzdHJpbmdbXSA9IFsnYWRkcmVzcyddO1xuXG4gIEBJbnB1dCgpXG4gIHR5cGU/OiBzdHJpbmc7XG5cbiAgQElucHV0KClcbiAgYXV0b0NvbXBsZXRlT3B0aW9uczogQXV0b2NvbXBsZXRlT3B0aW9ucyA9IHt9O1xuXG4gIEBPdXRwdXQoKVxuICBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0IHwgc3RyaW5nIHwgbnVsbD4gPSBuZXcgRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0IHwgc3RyaW5nIHwgbnVsbD4oKTtcblxuICBAT3V0cHV0KClcbiAgb25BdXRvY29tcGxldGVTZWxlY3RlZDogRXZlbnRFbWl0dGVyPFBsYWNlUmVzdWx0PiA9IG5ldyBFdmVudEVtaXR0ZXI8UGxhY2VSZXN1bHQ+KCk7XG5cbiAgQE91dHB1dCgpXG4gIG9uR2VybWFuQWRkcmVzc01hcHBlZDogRXZlbnRFbWl0dGVyPEdlcm1hbkFkZHJlc3M+ID0gbmV3IEV2ZW50RW1pdHRlcjxHZXJtYW5BZGRyZXNzPigpO1xuXG4gIEBPdXRwdXQoKVxuICBvbkxvY2F0aW9uU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxMb2NhdGlvbj4gPSBuZXcgRXZlbnRFbWl0dGVyPExvY2F0aW9uPigpO1xuXG5cbiAgcHJpdmF0ZSBvbk5ld1BsYWNlUmVzdWx0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgcHJpdmF0ZSBhZGRyZXNzVmFsaWRhdG9yOiBNYXRWYWxpZGF0ZUFkZHJlc3NEaXJlY3RpdmUgPSBuZXcgTWF0VmFsaWRhdGVBZGRyZXNzRGlyZWN0aXZlKCk7XG5cbiAgcHVibGljIGFkZHJlc3NTZWFyY2hDb250cm9sOiBGb3JtQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCh7dmFsdWU6IG51bGx9LCBWYWxpZGF0b3JzLmNvbXBvc2UoW1xuICAgIFZhbGlkYXRvcnMucmVxdWlyZWQsXG4gICAgdGhpcy5hZGRyZXNzVmFsaWRhdG9yLnZhbGlkYXRlKCldKVxuICApO1xuXG4gIHByb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHtcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1hcHNBUElMb2FkZXI6IE1hcHNBUElMb2FkZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHtcbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuYWRkcmVzc1ZhbGlkYXRvci5zdWJzY3JpYmUodGhpcy5vbk5ld1BsYWNlUmVzdWx0KTtcblxuICAgIGNvbnN0IG9wdGlvbnM6IEF1dG9jb21wbGV0ZU9wdGlvbnMgPSB7XG4gICAgICAvLyB0eXBlczogWydhZGRyZXNzJ10sXG4gICAgICAvLyBjb21wb25lbnRSZXN0cmljdGlvbnM6IHtjb3VudHJ5OiB0aGlzLmNvdW50cnl9LFxuICAgICAgcGxhY2VJZE9ubHk6IHRoaXMucGxhY2VJZE9ubHksXG4gICAgICBzdHJpY3RCb3VuZHM6IHRoaXMuc3RyaWN0Qm91bmRzLFxuICAgICAgLy8gdHlwZXM6IHRoaXMudHlwZXMsXG4gICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICB9O1xuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgdGhpcy5jb3VudHJ5ID8gb3B0aW9ucy5jb21wb25lbnRSZXN0cmljdGlvbnMgPSB7Y291bnRyeTogdGhpcy5jb3VudHJ5fSA6IG51bGw7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgdGhpcy5jb3VudHJ5ID8gb3B0aW9ucy50eXBlcyA9IHRoaXMudHlwZXMgOiBudWxsO1xuXG4gICAgdGhpcy5hdXRvQ29tcGxldGVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih0aGlzLmF1dG9Db21wbGV0ZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuaW5pdEdvb2dsZU1hcHNBdXRvY29tcGxldGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0R29vZ2xlTWFwc0F1dG9jb21wbGV0ZSgpIHtcbiAgICB0aGlzLm1hcHNBUElMb2FkZXJcbiAgICAgIC5sb2FkKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlID0gbmV3IGdvb2dsZS5tYXBzLnBsYWNlcy5BdXRvY29tcGxldGUodGhpcy5zZWFyY2hFbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuYXV0b0NvbXBsZXRlT3B0aW9ucyk7XG4gICAgICAgIGF1dG9jb21wbGV0ZS5hZGRMaXN0ZW5lcigncGxhY2VfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBwbGFjZSByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlOiBQbGFjZVJlc3VsdCA9IGF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBnZXJtYW5BZGRyZXNzOiBHZXJtYW5BZGRyZXNzID0ge1xuICAgICAgICAgICAgICBnbUlEOiBwbGFjZS5pZCxcbiAgICAgICAgICAgICAgaWNvbjogcGxhY2UuaWNvbixcbiAgICAgICAgICAgICAgdXJsOiBwbGFjZS51cmwsXG4gICAgICAgICAgICAgIHBsYWNlSUQ6IHBsYWNlLnBsYWNlX2lkLFxuICAgICAgICAgICAgICBkaXNwbGF5QWRkcmVzczogcGxhY2UuZm9ybWF0dGVkX2FkZHJlc3MsXG4gICAgICAgICAgICAgIG5hbWU6IHBsYWNlLm5hbWUsXG4gICAgICAgICAgICAgIHZpY2luaXR5OiBwbGFjZS52aWNpbml0eSxcbiAgICAgICAgICAgICAgbG9jYWxpdHk6IHt9LFxuICAgICAgICAgICAgICBzdGF0ZToge30sXG4gICAgICAgICAgICAgIGNvdW50cnk6IHt9LFxuICAgICAgICAgICAgICBnZW9Mb2NhdGlvbjoge2xhdGl0dWRlOiAtMSwgbG9uZ2l0dWRlOiAtMX0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocGxhY2UuZ2VvbWV0cnkgJiYgcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5nZW9Mb2NhdGlvbi5sYXRpdHVkZSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxhdCgpO1xuICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmdlb0xvY2F0aW9uLmxvbmdpdHVkZSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHMuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdzdHJlZXRfbnVtYmVyJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3Muc3RyZWV0TnVtYmVyID0gdmFsdWUuc2hvcnRfbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZigncm91dGUnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5zdHJlZXROYW1lID0gdmFsdWUubG9uZ19uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdwb3N0YWxfY29kZScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLnBvc3RhbENvZGUgPSBOdW1iZXIodmFsdWUuc2hvcnRfbmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGVzLmluZGV4T2YoJ3N1YmxvY2FsaXR5JykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3Muc3VibG9jYWxpdHkgPSB2YWx1ZS5sb25nX25hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGVzLmluZGV4T2YoJ2xvY2FsaXR5JykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3MubG9jYWxpdHkubG9uZyA9IHZhbHVlLmxvbmdfbmFtZTtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmxvY2FsaXR5LnNob3J0ID0gdmFsdWUuc2hvcnRfbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8xJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIGdlcm1hbkFkZHJlc3Muc3RhdGUubG9uZyA9IHZhbHVlLmxvbmdfbmFtZTtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLnN0YXRlLnNob3J0ID0gdmFsdWUuc2hvcnRfbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUudHlwZXMuaW5kZXhPZignY291bnRyeScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmNvdW50cnkubG9uZyA9IHZhbHVlLmxvbmdfbmFtZTtcbiAgICAgICAgICAgICAgICBnZXJtYW5BZGRyZXNzLmNvdW50cnkuc2hvcnQgPSB2YWx1ZS5zaG9ydF9uYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlcy5pbmRleE9mKCdhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzMnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZ2VybWFuQWRkcmVzcy5sb2NhbGl0eS5zaG9ydCA9IHZhbHVlLnNob3J0X25hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLm9uR2VybWFuQWRkcmVzc01hcHBlZC5lbWl0KGdlcm1hbkFkZHJlc3MpO1xuXG4gICAgICAgICAgICBpZiAoIXBsYWNlLnBsYWNlX2lkIHx8IHBsYWNlLmdlb21ldHJ5ID09PSB1bmRlZmluZWQgfHwgcGxhY2UuZ2VvbWV0cnkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gcGxhY2UgcmVzdWx0IGlzIG5vdCB2YWxpZFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzaG93IGRpYWxvZyB0byBzZWxlY3QgYSBhZGRyZXNzIGZyb20gdGhlIGlucHV0XG4gICAgICAgICAgICAgIC8vIGVtaXQgZmFpbGVkIGV2ZW50XG4gICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwbGFjZTtcbiAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UodGhpcy52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkcmVzcyA9IHBsYWNlLmZvcm1hdHRlZF9hZGRyZXNzO1xuICAgICAgICAgICAgdGhpcy5vbkF1dG9jb21wbGV0ZVNlbGVjdGVkLmVtaXQocGxhY2UpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ29uQXV0b2NvbXBsZXRlU2VsZWN0ZWQgLT4gJywgcGxhY2UpO1xuICAgICAgICAgICAgdGhpcy5vbkxvY2F0aW9uU2VsZWN0ZWQuZW1pdChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKSxcbiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5sb2coZXJyKSk7XG4gIH1cblxuICBwdWJsaWMgb25RdWVyeShldmVudDogYW55KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ29uQ2hhbmdlKCknLCBldmVudCk7XG4gICAgdGhpcy5vbkNoYW5nZS5lbWl0KHRoaXMuYWRkcmVzcyk7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0QWRkcmVzcygpIHtcbiAgICB0aGlzLmFkZHJlc3MgPSBudWxsO1xuICAgIHRoaXMuYWRkcmVzc1NlYXJjaENvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICB9XG5cbiAgd3JpdGVWYWx1ZShvYmo6IGFueSk6IHZvaWQge1xuICAgIGlmIChvYmopIHtcbiAgICAgIHRoaXMudmFsdWUgPSBvYmo7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBzZXREaXNhYmxlZFN0YXRlPyhpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbn1cbiIsIjxtYXQtZm9ybS1maWVsZCBjbGFzcz1cImZ1bGwtd2lkdGhcIiBbYXBwZWFyYW5jZV09XCJhcHBlYXJhbmNlXCI+XG4gIDxtYXQtbGFiZWw+e3thZGRyZXNzTGFiZWxUZXh0fX08L21hdC1sYWJlbD5cbiAgPGlucHV0IG1hdElucHV0XG4gICAgICAgICBbKG5nTW9kZWwpXT1cImFkZHJlc3NcIlxuICAgICAgICAgKGNoYW5nZSk9XCJvblF1ZXJ5KCRldmVudClcIlxuICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7e3BsYWNlaG9sZGVyVGV4dH19XCJcbiAgICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICAgICNzZWFyY2hcbiAgICAgICAgIE1hdFZhbGlkYXRlQWRkcmVzc1xuICAgICAgICAgcmVxdWlyZWQ+XG4gIDxtYXQtZXJyb3IgKm5nSWY9XCJhZGRyZXNzU2VhcmNoQ29udHJvbC5oYXNFcnJvcigncmVxdWlyZWQnKVwiPlxuICAgIHt7cmVxdWlyZWRFcnJvclRleHR9fVxuICA8L21hdC1lcnJvcj5cbiAgPG1hdC1lcnJvciAqbmdJZj1cImFkZHJlc3NTZWFyY2hDb250cm9sLmhhc0Vycm9yKCd2YWxpZGF0ZUFkZHJlc3MnKVwiPlxuICAgIHt7aW52YWxpZEVycm9yVGV4dH19XG4gIDwvbWF0LWVycm9yPlxuPC9tYXQtZm9ybS1maWVsZD5cbiJdfQ==